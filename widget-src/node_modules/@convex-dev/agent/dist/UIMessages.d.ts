import { type UIMessage as AIUIMessage, type UIDataTypes, type UITools } from "ai";
import type { MessageDoc, MessageStatus, ProviderOptions } from "./validators.js";
export type UIStatus = "streaming" | MessageStatus;
export type UIMessage<METADATA = unknown, DATA_PARTS extends UIDataTypes = UIDataTypes, TOOLS extends UITools = UITools> = AIUIMessage<METADATA, DATA_PARTS, TOOLS> & {
    key: string;
    order: number;
    stepOrder: number;
    status: UIStatus;
    agentName?: string;
    text: string;
    _creationTime: number;
};
/**
 * Converts a list of UIMessages to MessageDocs, along with extra metadata that
 * may be available to associate with the MessageDocs.
 * @param messages - The UIMessages to convert to MessageDocs.
 * @param meta - The metadata to add to the MessageDocs.
 * @returns
 */
export declare function fromUIMessages<METADATA = unknown>(messages: UIMessage<METADATA>[], meta: {
    threadId: string;
    userId?: string;
    model?: string;
    provider?: string;
    providerOptions?: ProviderOptions;
    metadata?: METADATA;
}): (MessageDoc & {
    streaming: boolean;
    metadata?: METADATA;
})[];
type ExtraFields<METADATA = unknown> = {
    streaming?: boolean;
    metadata?: METADATA;
};
/**
 * Converts a list of MessageDocs to UIMessages.
 * This is somewhat lossy, as many fields are not supported by UIMessages, e.g.
 * the model, provider, userId, etc.
 * The UIMessage type is the augmented type that includes more fields such as
 * key, order, stepOrder, status, agentName, text, etc.
 */
export declare function toUIMessages<METADATA = unknown, DATA_PARTS extends UIDataTypes = UIDataTypes, TOOLS extends UITools = UITools>(messages: (MessageDoc & ExtraFields<METADATA>)[]): UIMessage<METADATA, DATA_PARTS, TOOLS>[];
export declare function combineUIMessages(messages: UIMessage[]): UIMessage[];
export {};
//# sourceMappingURL=UIMessages.d.ts.map