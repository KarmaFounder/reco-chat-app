import { type UIMessageChunk } from "ai";
import { type UIMessage } from "./UIMessages.js";
import { type MessageStatus, type StreamDelta, type StreamMessage } from "./validators.js";
export declare function blankUIMessage<METADATA = unknown>(streamMessage: StreamMessage & {
    metadata?: METADATA;
}, threadId: string): UIMessage<METADATA>;
export declare function statusFromStreamStatus(status: StreamMessage["status"]): MessageStatus | "streaming";
export declare function updateFromUIMessageChunks(uiMessage: UIMessage, parts: UIMessageChunk[]): Promise<UIMessage>;
export declare function deriveUIMessagesFromDeltas(threadId: string, streamMessages: StreamMessage[], allDeltas: StreamDelta[]): Promise<UIMessage[]>;
/**
 *
 */
export declare function deriveUIMessagesFromTextStreamParts(threadId: string, streamMessages: StreamMessage[], existingStreams: Array<{
    streamId: string;
    cursor: number;
    message: UIMessage;
}>, allDeltas: StreamDelta[]): [
    UIMessage[],
    Array<{
        streamId: string;
        cursor: number;
        message: UIMessage;
    }>,
    boolean
];
export declare function getParts<T extends StreamDelta["parts"][number]>(deltas: StreamDelta[], fromCursor?: number): {
    parts: T[];
    cursor: number;
};
/**
 * This is historically from when we would use the onChunk callback instead of
 * consuming the full UIMessageStream.
 */
export declare function updateFromTextStreamParts(threadId: string, streamMessage: StreamMessage, existing: {
    streamId: string;
    cursor: number;
    message: UIMessage;
} | undefined, deltas: StreamDelta[]): [{
    streamId: string;
    cursor: number;
    message: UIMessage;
}, boolean];
//# sourceMappingURL=deltas.d.ts.map