import { type UIMessage as AIMessage, type AssistantContent, type ModelMessage, type DataContent, type FilePart, type GenerateObjectResult, type ImagePart, type StepResult, type ToolContent, type ToolSet, type UserContent, type FileUIPart, type LanguageModelUsage, type CallWarning, type ToolResultPart, type JSONValue } from "ai";
import { type Message, type MessageWithMetadata, type Usage, type MessageDoc } from "./validators.js";
import type { ActionCtx, AgentComponent } from "./client/types.js";
import type { MutationCtx } from "./client/types.js";
import { type ModelOrMetadata } from "./shared.js";
export type AIMessageWithoutId = Omit<AIMessage, "id">;
export type SerializeUrlsAndUint8Arrays<T> = T extends URL ? string : T extends Uint8Array | ArrayBufferLike ? ArrayBuffer : T extends Array<infer Inner> ? Array<SerializeUrlsAndUint8Arrays<Inner>> : T extends Record<string, any> ? {
    [K in keyof T]: SerializeUrlsAndUint8Arrays<T[K]>;
} : T;
export type Content = UserContent | AssistantContent | ToolContent;
export type SerializedContent = Message["content"];
export type SerializedMessage = Message;
export declare function serializeMessage(ctx: ActionCtx | MutationCtx, component: AgentComponent, message: ModelMessage | Message): Promise<{
    message: SerializedMessage;
    fileIds?: string[];
}>;
export declare function fromModelMessage(message: ModelMessage): Message;
export declare function serializeOrThrow(message: ModelMessage | Message): Promise<SerializedMessage>;
export declare function toModelMessage(message: SerializedMessage | ModelMessage): ModelMessage;
export declare function docsToModelMessages(messages: MessageDoc[]): ModelMessage[];
export declare function serializeUsage(usage: LanguageModelUsage): Usage;
export declare function toModelMessageUsage(usage: Usage): LanguageModelUsage;
export declare function serializeWarnings(warnings: CallWarning[] | undefined): MessageWithMetadata["warnings"];
export declare function toModelMessageWarnings(warnings: MessageWithMetadata["warnings"]): CallWarning[] | undefined;
export declare function serializeNewMessagesInStep<TOOLS extends ToolSet>(ctx: ActionCtx, component: AgentComponent, step: StepResult<TOOLS>, model: ModelOrMetadata | undefined): Promise<{
    messages: MessageWithMetadata[];
}>;
export declare function serializeObjectResult(ctx: ActionCtx, component: AgentComponent, result: GenerateObjectResult<unknown>, model: ModelOrMetadata | undefined): Promise<{
    messages: MessageWithMetadata[];
}>;
export declare function serializeContent(ctx: ActionCtx | MutationCtx, component: AgentComponent, content: Content | Message["content"]): Promise<{
    content: SerializedContent;
    fileIds?: string[];
}>;
export declare function fromModelMessageContent(content: Content): Message["content"];
export declare function toModelMessageContent(content: SerializedContent | ModelMessage["content"]): Content;
export declare function normalizeToolOutput(result: string | JSONValue | undefined): ToolResultPart["output"];
/**
 * Return a best-guess MIME type based on the magic-number signature
 * found at the start of an ArrayBuffer.
 *
 * @param buf â€“ the source ArrayBuffer
 * @returns the detected MIME type, or `"application/octet-stream"` if unknown
 */
export declare function guessMimeType(buf: ArrayBuffer | string): string;
/**
 * Serialize an AI SDK `DataContent` or `URL` to a Convex-serializable format.
 * @param dataOrUrl - The data or URL to serialize.
 * @returns The serialized data as an ArrayBuffer or the URL as a string.
 */
export declare function serializeDataOrUrl(dataOrUrl: DataContent | URL): ArrayBuffer | string;
export declare function toModelMessageDataOrUrl(urlOrString: string | ArrayBuffer | URL | DataContent): URL | DataContent;
export declare function toUIFilePart(part: ImagePart | FilePart): FileUIPart;
//# sourceMappingURL=mapping.d.ts.map